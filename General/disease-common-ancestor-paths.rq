##### THIS IS INCOMPLETE!!!! #####
# it doesn't necessarily find the nearest common ancestor; it finds a common
# ancestor and then excludes its parents; there is no current calculation that
# identifies the actual shortest path (should that be cumulative for all
# diseases, or just the shortest single path from one disease to the ancestor?)

#id: DOq... (works but only returns 1 LCA if multiple)
#description: >-
#  Find the nearest common disease ancestor of multiple diseases and show
#  the path to that ancestor. Example uses appendicitis (DOID:8337), alcoholic
#  gastritis (DOID:8680), and viral esophagitis (DOID:6297)
#input: doid.owl
#comment: >-
#  Two things of note:
#  1. If more than one nearest common ancestor exists, only one will be
#  returned;
#  2. Disease IRIs must be added in two locations in the query: to find the
#  nearest common ancestor (in the subquery, #1) and to assemble the path to the
#  ancestor (VALUES statement, #2)
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX oboInOwl: <http://www.geneontology.org/formats/oboInOwl#>
PREFIX DOID: <http://purl.obolibrary.org/obo/DOID_>

SELECT ?ancestor ?id ?label (GROUP_CONCAT(DISTINCT ?parent; separator=" > ") AS ?path)
WHERE {
	{
		# find the nearest common ancestor
		SELECT ?ancestor_iri (COUNT(?mid) AS ?distance)
		WHERE {
			?ancestor_iri ^rdfs:subClassOf* ?mid .
			# DISEASE IRI LOCATION #1
			# NOTE: use + instead of * to speed up; caveat: ancestor will be one
			#   above common ancestor IF the common ancestor is in the set
			?mid ^rdfs:subClassOf* DOID:8337, DOID:8680, DOID:6297 .
			FILTER(!isBlank(?ancestor_iri)) # exclude blank nodes
		}
		GROUP BY ?ancestor_iri
		ORDER BY ?distance
		LIMIT 1
	}

	#### ASSEMBLE PATH TO ANCESTOR ####
	# DISEASE IRI LOCATION #2
	VALUES ?iri { DOID:8337 DOID:8680 DOID:6297 }

	?iri oboInOwl:id ?id ;
		rdfs:label ?label ;
		rdfs:subClassOf* ?mid .
	# NOTE: use + instead of * to speed up; caveat: ancestor will be one above
	#   common ancestor IF the common ancestor is in the set AND the path will
	#   not be complete
	?mid rdfs:subClassOf* ?ancestor_iri .

	?ancestor_iri  oboInOwl:id ?ancestor_id ;
		rdfs:label ?ancestor_label .
	BIND(CONCAT(?ancestor_label, " (", ?ancestor_id, ")") AS ?ancestor)

	?mid oboInOwl:id ?mid_id ;
		rdfs:label ?mid_label .
	BIND(CONCAT(?mid_label, " (", ?mid_id, ")") AS ?parent)
}
GROUP BY ?ancestor ?id ?label